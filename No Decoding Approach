from kivy.uix.image import Image
from kivy.uix.floatlayout import FloatLayout
from kivy.uix.screenmanager import Screen
from kivy.uix.widget import Widget
from kivy.graphics import Color, RoundedRectangle, Rectangle
from kivy.uix.label import Label
from HoverItem import HoverItem
from kivy.core.window import Window
from kivy.clock import Clock
from kivy.animation import Animation
from kivy.properties import NumericProperty
import os

class FadeOverlay(Widget):
    opacity_level = NumericProperty(1)

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        with self.canvas:
            Color(0, 0, 0, 1)
            self.rect = Rectangle(pos=self.pos, size=self.size)
        self.bind(pos=self.update_rect, size=self.update_rect, opacity_level=self.update_opacity)

    def update_rect(self, *args):
        self.rect.pos = self.pos
        self.rect.size = self.size

    def update_opacity(self, *args):
        self.canvas.clear()
        with self.canvas:
            Color(0, 0, 0, self.opacity_level)
            self.rect = Rectangle(pos=self.pos, size=self.size)

class StartScreen(Screen):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = "StartScreen"

        self.root = FloatLayout()
        self.fade_overlay = FadeOverlay(size_hint=(1, 1), pos_hint={"x": 0, "y": 0})
        self.root.add_widget(self.fade_overlay, index=100)

        self.keep_clicking_label = Label(
            text="KEEP CLICKING",
            font_size="64sp",
            bold=True,
            opacity=0,
            color=(1, 1, 1, 1),
            size_hint=(1, 1),
            pos_hint={"x": 0, "y": 0.47},
            halign="center",
            valign="middle"
        )
        self.keep_clicking_label.bind(size=self.update_label_text_size)
        self.root.add_widget(self.keep_clicking_label, index=101)

        self.add_background(self.root)
        self.add_buttons(self.root)
        self.add_image_sequence(self.root)

        self.add_widget(self.root)
        self._touch_bound = True

    def update_label_text_size(self, instance, value):
        instance.text_size = value

    def add_background(self, root):
        with root.canvas.before:
            Color(0.1, 0.1, 0.1, 1)
            self.ui_rect = RoundedRectangle(pos=root.pos, size=root.size)
        root.bind(pos=self.update_ui_background, size=self.update_ui_background)

    def update_ui_background(self, instance, *args):
        self.ui_rect.pos = instance.pos
        self.ui_rect.size = instance.size

    def add_image_sequence(self, root):
        """Lightweight alternative - use static images instead of videos"""
        local_dir = os.path.dirname(__file__)
        downloads_dirs = [
            os.path.join(os.path.expanduser('~'), 'Downloads'),
            r'C:\Users\Vislab Admin\Downloads',
        ]
        
        # Look for image files instead of videos
        image_filenames = [
            "m_to_nm_title.png",     # Key frame from title video
            "m_to_nm_julian.png",    # Key frame from julian video
            "m_to_nm_remote.png",    # etc.
            "m_to_nm_battery.png",
            "m_to_nm_separator.png",
            "m_to_nm_ions_still.png",
            "m_to_nm_ions_moving.png",
            "m_to_nm_loop.png"       # Loop background image
        ]
        
        self.image_paths = []
        for fname in image_filenames:
            local_path = os.path.join(local_dir, fname)
            if os.path.exists(local_path):
                self.image_paths.append(local_path)
                continue
            for downloads_dir in downloads_dirs:
                downloads_path = os.path.join(downloads_dir, fname)
                if os.path.exists(downloads_path):
                    self.image_paths.append(downloads_path)
                    break

        if not self.image_paths:
            print("[ERROR] No intro images found.")
            return

        self.image_index = 0
        self.current_image = None
        self.show_current_image()
        Window.bind(on_touch_down=self.on_touch_down_global)

    def show_current_image(self):
        """Show current image in sequence - much lighter than video"""
        if self.image_index >= len(self.image_paths):
            self.start_loop_image()
            return

        # Remove previous image
        if self.current_image:
            self.root.remove_widget(self.current_image)

        # Hide label for fresh image
        self.keep_clicking_label.opacity = 0

        # Create new image widget (much lighter than video)
        image_path = self.image_paths[self.image_index]
        print(f"[INFO] Showing image {self.image_index + 1}: {os.path.basename(image_path)}")

        self.current_image = Image(
            source=image_path,
            allow_stretch=True,
            keep_ratio=False,
            size_hint=(1, 1),
            pos_hint={"x": 0, "y": 0},
            opacity=0
        )
        
        self.root.add_widget(self.current_image, index=1)
        self.bring_buttons_to_front()

        # Fade in image
        Animation(opacity=1, duration=0.5).start(self.current_image)
        Animation(opacity_level=0, duration=0.6).start(self.fade_overlay)

        # Auto-advance after 3 seconds OR wait for click
        Clock.schedule_once(lambda dt: self.show_click_prompt(), 3.0)

    def show_click_prompt(self):
        """Show click prompt after image displays"""
        if self.image_index < len(self.image_paths) - 1:
            Animation(opacity_level=1, duration=0.5).start(self.fade_overlay)
            Animation(opacity=1, duration=0.6).start(self.keep_clicking_label)

    def advance_image(self):
        """Advance to next image"""
        if self.image_index < len(self.image_paths) - 1:
            self.image_index += 1
            
            # Smooth transition
            def _fade_to_next(*_):
                fade_black = Animation(opacity_level=1, duration=0.6)
                fade_black.bind(on_complete=lambda *_: self.show_current_image())
                fade_black.start(self.fade_overlay)

            label_out = Animation(opacity=0, duration=0.4)
            label_out.bind(on_complete=_fade_to_next)
            label_out.start(self.keep_clicking_label)
        else:
            # Last image - go to loop
            self.start_loop_image()

    def start_loop_image(self):
        """Show loop background image"""
        Window.unbind(on_touch_down=self.on_touch_down_global)
        
        if self.current_image:
            self.root.remove_widget(self.current_image)

        self.keep_clicking_label.opacity = 0

        # Use last image as loop background
        loop_path = self.image_paths[-1] if self.image_paths else None
        if not loop_path:
            print("[ERROR] No loop image available")
            return

        self.current_image = Image(
            source=loop_path,
            allow_stretch=True,
            keep_ratio=False,
            size_hint=(1, 1),
            pos_hint={"x": 0, "y": 0},
            opacity=0
        )
        
        self.root.add_widget(self.current_image, index=1)
        self.bring_buttons_to_front()

        Animation(opacity=1, duration=0.5).start(self.current_image)
        Animation(opacity_level=0, duration=0.5).start(self.fade_overlay)
        print("[INFO] Loop background image shown")

    def add_buttons(self, root):
        self.panel_wrapper = Widget(size_hint=(None, None), size=(1000, 100), pos=(root.width / 2 - 470, 10))
        with self.panel_wrapper.canvas:
            Color(0.0, 0.0, 0.0, 0.4)
            self.button_panel = RoundedRectangle(size=self.panel_wrapper.size, pos=self.panel_wrapper.pos, radius=[25])
        root.bind(size=self.update_button_panel, pos=self.update_button_panel)
        root.add_widget(self.panel_wrapper)

        self.start_button = HoverItem(
            size_hint=(0.2, 0.1),
            pos_hint={"center_x": 0.35, "center_y": 0.05},
            hoverSource="Graphics/Start_Highlighted.png",
            defaultSource="Graphics/Start.png",
            function=lambda x: self.start_game()
        )

        self.tutorial_button = HoverItem(
            size_hint=(0.2, 0.1),
            pos_hint={"center_x": 0.65, "center_y": 0.05},
            hoverSource="Graphics/Tutorial_Highlighted.png",
            defaultSource="Graphics/Tutorial.png",
            function=lambda x: print("Tutorial clicked")
        )

        root.add_widget(self.start_button)
        root.add_widget(self.tutorial_button)

    def bring_buttons_to_front(self):
        for widget in [self.panel_wrapper, self.start_button, self.tutorial_button, self.keep_clicking_label]:
            if widget.parent:
                self.root.remove_widget(widget)
                Clock.schedule_once(lambda dt, w=widget: self.root.add_widget(w), 0)

    def update_button_panel(self, *args):
        if hasattr(self, 'button_panel'):
            self.panel_wrapper.pos = (self.root.width / 2 - 470, 10)
            self.button_panel.pos = self.panel_wrapper.pos
            self.button_panel.size = (1000, 100)
            self.panel_wrapper.size = (1000, 100)

    def on_touch_down_global(self, window, touch):
        # Only advance if we're showing click prompt
        if self.keep_clicking_label.opacity > 0:
            self.advance_image()
        return False

    def start_game(self):
        # Much simpler cleanup - just remove image
        if self.current_image:
            self.root.remove_widget(self.current_image)
            self.current_image = None
            
        if self._touch_bound:
            try:
                Window.unbind(on_touch_down=self.on_touch_down_global)
            except Exception:
                pass
            self._touch_bound = False
        self.manager.current = "GameScreen"

    def on_pre_leave(self, *args):
        """Lightweight cleanup"""
        print("[INFO] Leaving StartScreen - minimal cleanup needed")
        if self.current_image:
            self.root.remove_widget(self.current_image)
            self.current_image = None
        
        if self._touch_bound:
            try:
                Window.unbind(on_touch_down=self.on_touch_down_global)
            except Exception:
                pass
            self._touch_bound = False

    def on_pre_enter(self, *args):
        """Resume image sequence"""
        if not self._touch_bound:
            try:
                Window.bind(on_touch_down=self.on_touch_down_global)
                self._touch_bound = True
            except Exception:
                pass
        
        # Resume from current position
        if hasattr(self, 'image_paths') and self.image_paths:
            if self.image_index >= len(self.image_paths):
                self.start_loop_image()
            else:
                self.show_current_image()
